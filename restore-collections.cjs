const sdk = require('node-appwrite');
const fs = require('fs');

// Leer variables de entorno
require('dotenv').config();

const client = new sdk.Client();
const databases = new sdk.Databases(client);

client
    .setEndpoint(process.env.VITE_APPWRITE_PUBLIC_ENDPOINT)
    .setProject(process.env.VITE_APPWRITE_PROJECT_ID)
    .setKey(process.env.APPWRITE_API_KEY); // Necesitar√°s una API Key

const DATABASE_ID = '68b1d7530028045d94d3';

// Funci√≥n para esperar
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Funci√≥n para crear atributo seg√∫n su tipo
async function createAttribute(collectionId, attr) {
    const { key, type, required = false, array = false } = attr;
    
    // L√ìGICA DE CORRECCI√ìN (del error 'required/default'):
    const defaultValue = required ? undefined : attr.default;

    try {
        console.log(`  Creando atributo: ${key} (${type})`);
        
        switch (type) {
            case 'string':
                
                // --- INICIO MODIFICACI√ìN (Control de L√≠mite de TAMA√ëO v3) ---
                
                // 1. Manejar 'size: 0' (que significa 'ilimitado' o TEXT)
                let size;
                if (attr.size === 0) {
                    size = 0;
                } else {
                    // Si no es 0, usamos el tama√±o del attr o 255 por defecto
                    size = attr.size || 255;
                }

                // 2. Capar el tama√±o. Bajamos el l√≠mite a 8000 por seguridad.
                if (size > 1000) { 
                    console.warn(`  ‚ö†Ô∏è  Tama√±o original de ${key} (${size}) excede el l√≠mite de seguridad. Capando a 8000.`);
                    size = 1000;
                }
                // --- FIN MODIFICACI√ìN ---

                await databases.createStringAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    size, // Usamos la variable 'size' modificada
                    required,
                    defaultValue, 
                    array
                );
                break;
                
            case 'email':
                await databases.createEmailAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    required,
                    defaultValue, 
                    array
                );
                break;
                
            case 'integer':
                await databases.createIntegerAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    required,
                    attr.min,
                    attr.max,
                    defaultValue, 
                    array
                );
                break;
                
            case 'double':
                await databases.createFloatAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    required,
                    attr.min,
                    attr.max,
                    defaultValue, 
                    array
                );
                break;
                
            case 'boolean':
                await databases.createBooleanAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    required,
                    defaultValue, 
                    array
                );
                break;
                
            case 'datetime':
                await databases.createDatetimeAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    required,
                    defaultValue, 
                    array
                );
                break;
                
            case 'enum':
                // Convertir enum a string con tama√±o 50 (esto est√° bien, no se cambia)
                console.log(`    NOTA: Convirtiendo enum a string (valores: ${attr.elements.join(', ')})`);
                await databases.createStringAttribute(
                    DATABASE_ID,
                    collectionId,
                    key,
                    50,
                    required,
                    defaultValue, 
                    array
                );
                break;
                
            default:
                console.warn(`  ‚ö†Ô∏è  Tipo de atributo desconocido: ${type}`);
        }
        
        // Esperar 2 segundos entre atributos
        await sleep(2000);
        console.log(`  ‚úì Atributo ${key} creado`);
        
    } catch (error) {
        // CAPTURAR ERROR 409 (CONFLICTO / YA EXISTE)
        if (error.code === 409 || error.type === 'attribute_already_exists') {
            console.warn(`  ‚ö†Ô∏è  Atributo ${key} ya existe. Omitiendo.`);
        } else {
            // Si es un error DIFERENTE (como el de 'limit_exceeded'),
            // s√≠ lo mostramos y detenemos el script.
            console.error(`  ‚úó Error creando atributo ${key}:`, error.message);
            throw error;
        }
    }
}

// Funci√≥n para crear √≠ndice (VERSI√ìN ROBUSTA)
async function createIndex(collectionId, index) {
    const { key, type, attributes, orders = [] } = index;
    
    try {
        // 1. Verificar que la colecci√≥n existe y obtener sus atributos
        let collection;
        try {
            collection = await databases.getCollection(DATABASE_ID, collectionId);
        } catch (error) {
            console.warn(`  ‚ö†Ô∏è  No se pudo acceder a la colecci√≥n ${collectionId}. √çndice ${key} omitido.`);
            return;
        }
        
        // 2. Verificar que todos los atributos del √≠ndice existen
        const existingAttrs = collection.attributes.map(a => a.key);
        const missingAttrs = attributes.filter(attr => !existingAttrs.includes(attr));
        
        if (missingAttrs.length > 0) {
            console.warn(`  ‚ö†Ô∏è  √çndice ${key} omitido: atributos faltantes: ${missingAttrs.join(', ')}`);
            return;
        }
        
        console.log(`  Creando √≠ndice: ${key} (${type}) sobre: ${attributes.join(', ')}`);
        
        // 3. Crear el √≠ndice
        await databases.createIndex(
            DATABASE_ID,
            collectionId,
            key,
            type,
            attributes,
            orders
        );
        
        await sleep(2000);
        console.log(`  ‚úì √çndice ${key} creado`);
        
    } catch (error) {
        if (error.code === 409 || error.type === 'index_already_exists') {
            console.warn(`  ‚ö†Ô∏è  √çndice ${key} ya existe. Omitiendo.`);
        } else if (error.type === 'attribute_not_available') {
            console.warn(`  ‚ö†Ô∏è  √çndice ${key} omitido: atributo no disponible.`);
        } else {
            console.warn(`  ‚ö†Ô∏è  Error en √≠ndice ${key}: ${error.message}. Continuando...`);
            // NO lanzar error, solo advertir
        }
    }
}

// Funci√≥n principal de restauraci√≥n
async function restoreCollections() {
    console.log('='.repeat(60));
    console.log('RESTAURACI√ìN DE COLECCIONES DE APPWRITE');
    console.log('='.repeat(60));
    console.log();
    
    // Leer archivo de respaldo
    const config = JSON.parse(fs.readFileSync('appwrite.config.json.enum-backup', 'utf8'));
    const collections = config.collections;
    
    // Colecciones que necesitan restauraci√≥n completa (est√°n vac√≠as)
    const emptyCollections = [
        'empleados',
        'articulos',
        'citas',
        'facturas',
        'familias',
        'configuracion',
        'config',
        'templates',
        'campaigns',
        'campaign_progress',
        'message_logs'
    ];
    
    // 1. Restaurar atributos de colecciones vac√≠as
    console.log('PASO 1: Restaurando atributos de colecciones vac√≠as');
    console.log('-'.repeat(60));
    
    for (const collectionId of emptyCollections) {
        const collection = collections.find(c => c.$id === collectionId);
        if (!collection) {
            console.log(`‚ö†Ô∏è  Colecci√≥n ${collectionId} no encontrada en backup`);
            continue;
        }
        
        console.log(`\nüì¶ Restaurando colecci√≥n: ${collection.name} (${collectionId})`);
        console.log(`   Total de atributos: ${collection.attributes.length}`);
        
        for (const attr of collection.attributes) {
            await createAttribute(collectionId, attr);
        }
        
        console.log(`‚úì Colecci√≥n ${collection.name} restaurada con ${collection.attributes.length} atributos`);
    }
    
    console.log('\n' + '='.repeat(60));
    console.log('PASO 2: Creando √≠ndices faltantes');
    console.log('-'.repeat(60));
    
    // 2. Crear √≠ndices para todas las colecciones
    for (const collection of collections) {
        if (collection.indexes && collection.indexes.length > 0) {
            console.log(`\nüìá Creando √≠ndices para: ${collection.name} (${collection.$id})`);
            console.log(`   Total de √≠ndices: ${collection.indexes.length}`);
            
            for (const index of collection.indexes) {
                await createIndex(collection.$id, index);
            }
            
            console.log(`‚úì √çndices de ${collection.name} creados`);
        }
    }
    
    console.log('\n' + '='.repeat(60));
    console.log('‚úì RESTAURACI√ìN COMPLETADA');
    console.log('='.repeat(60));
    console.log('\nIMPORTANTE: Los atributos enum se han convertido a string.');
    console.log('Si necesitas validaci√≥n enum, deber√°s configurarla en tu aplicaci√≥n.');
    console.log('\nAtributos enum convertidos a string:');
    console.log('  ‚Ä¢ clientes.sexo (H, M, Otro)');
    console.log('  ‚Ä¢ articulos.tipo (producto, servicio, bono)');
    console.log('  ‚Ä¢ citas.estado (agendada, pendiente, finalizada, cancelada)');
    console.log('  ‚Ä¢ facturas.estado (borrador, cobrada, anulada)');
    console.log('  ‚Ä¢ facturas.metodoPago (Efectivo, Tarjeta, Transferencia, Mixto)');
    console.log('  ‚Ä¢ campaigns.estado (borrador, en_progreso, completada, pausada)');
    console.log('  ‚Ä¢ campaign_progress.estado (pendiente, enviado, fallido)');
    console.log('  ‚Ä¢ message_logs.estado (enviado, fallido, pendiente)');
}

// Ejecutar restauraci√≥n
restoreCollections()
    .then(() => {
        console.log('\n‚úì Script finalizado exitosamente');
        process.exit(0);
    })
    .catch((error) => {
        console.error('\n‚úó Error durante la restauraci√≥n:', error);
        process.exit(1);
    });